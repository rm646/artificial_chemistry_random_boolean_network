classdef rbmol < handle
    
    %stores all RBN information and vectors generated
    
    properties
        
        % vector related
            orbvec;         % set by the vectorizer when the object is passed to it
            numorbs;        % set by addition of numorbs properties of constituents when created
            orbtol;         % set by the vectorizer when the object is passed to it
            bonded;         % binaray row vector, 1  = bonded. Length = numorbs
            isatm;          % always =0 for molecule objects
            rot;            % record of how much rotation should be applied when new orbs are being generated by vectorize
            selfcon;        % connections between the atoms stored in archive (i.e. how to build it) Each column in the array is a bonded pair. Each element is a pair of indices specifying atom and orb.
            con;            % same as selfcon, but in terms of molecular orbitals
            
        % RBN related
            cyclemat;       % stores the RBN matrix for one period of the cycle found from the initial state defined by istate
            initialstate;   % initial conditions on the nodes as a boolean row vector. Simply derived from constituents.
            flashes;        % row vector of total number of flashes (on-off-on = 1 flash) for each node
            totals;         % sum over time of node values (0 and 1s)
            mboolmat;       % lookup tables
            seed;           % rng seed for reproducability
            n;              % total number of nodes
            k;              % number of inputs to each node
            K;              % connectivity matrix
            iters;          % number of time-steps to search for a cycle before giving up
            T;              % holds cycle-length for given RBN properties
            D;              % mnumorbsx2 matrix detailing how the nodes are divided into orbitals
            E;              % numorbsx2 matrix detailing how the orbitals are divided into atoms
            archive;        % array of atoms that formed the molecule
            
        % just in case
            isskynet = 0;
            prob_sentience = 0;

    end
    
    methods
        
        function ur = updaterotate(rbmol)
           
            x = rbmol.rot;
            if ~isempty(x)
            o = rbmol.orbvec;
            [~,max] = size(o);
            R = [cos(x),-sin(x);sin(x),cos(x)];
            % rotate each vector
            for j = 1:max
                o(:,j) = R*o(:,j);
            end
            
            ur = 1;
            else
            ur = 0;
            end
        end
        
        function randrotate = rr(rbmol, temp)     % rotates all vectors described by orbvec by a random angle scaled by temp and stores that angle (mod 2pi) in the rot property
            dir = (-1)^randi(2);        % positive for anti-clockwise
            x = 2*pi*temp*dir*rand;     %the angle
            o = rbmol.orbvec;
            [~,max] = size(o);
            R = [cos(x),-sin(x);sin(x),cos(x)];
            % rotate each vector
            for j = 1:max
                o(:,j) = R*o(:,j);
            end
            % update rot property
            rbmol.rot = mod(rbmol.rot + x, 2*pi);
            % update rot property of archive
            for j = 1:length(rbmol.archive)
                arch = rbmol.archive;
                arch{j}.rot = mod(arch{j}.rot + x, 2*pi);
            end
            randrotate = 1;
        end %rr
        
        function stategen = sg(rbmol)   % like the atomic version
            
            kk = rbmol.k;
            m = rbmol.n;
            T0 = rbmol.iters;
            KK = rbmol.K;
            B = rbmol.mboolmat;
            Pow = 2.^sum(triu(ones(kk),1));
            state = zeros(T0,m);             % pre-allocate matrix to store time-evolution of system
            X0 = rbmol.initialstate;
            X = X0(1,:);
            
            %find time-evolution over iters time steps
            
            for t = 1:T0
                V = (Pow * X(KK))+1;         % input value (k bits as number)
                X = diag(B(V,:));           % lookup boolean function, set X to the next state
                state(t,:) = X;             % store time step in state matrix
            end

            % search for a cycle, if found, set cyclemat to it
            [dupesout, ~] = unique(state,'rows');
            sized = size(dupesout);
            sizes = size(state);
            cyclefound = sized(1,1) < sizes(1,1);
            if cyclefound == 1      % search using tortoise and hare algorithm
                not_enough_iters = 0;
                tortoise = 1;
                hare = 2;
                while isequal(state(tortoise,:),state(hare,:)) == 0
                    tortoise = tortoise +1;
                    hare = hare + 2;
                    if hare == T0        % hare waits if tortoise gets to the end and a flag is set
                        hare = hare-2;
                        not_enough_iters = 1;
                    end
                end
                
                if not_enough_iters ==1
                disp('Cycle extraction failed')
                rbmol.cyclemat = state;
                stategen = 1;
                return
                end
                
                mu = 1;
                tortoise = 1;
                while isequal(state(tortoise,:),state(hare+1,:)) == 0       % add +1 to hare in argument because 0 index does not exist --> tortoise cannot be set to 0
                    tortoise = tortoise + 1;
                    hare = hare + 1;
                    mu = mu + 1;
                    if hare == T0        % hare waits if it gets to the end and a flag is set
                        hare = hare-1;
                        not_enough_iters = 1;
                    end
                end
                
                if not_enough_iters ==1
                disp('Cycle extraction failed')
                rbmol.cyclemat = state;
                stategen = 1;
                return
                end
                
                lam = 1;
                hare = tortoise + 1;
                while isequal(state(tortoise,:),state(hare,:)) == 0
                    hare = hare + 1;
                    lam = lam + 1;
                    if hare == T0        % hare waits if it gets to the end and a flag is set
                        hare = hare-1;
                        not_enough_iters = 1;
                    end
                end
                
                if not_enough_iters ==1
                disp('Cycle extraction failed')
                rbmol.cyclemat = state;
                stategen = 1;
                return
                end
                
                cstart = mu;
                cend = lam + mu;
                
                rbmol.cyclemat = state(cstart:(cend-1),:);
                stategen = 1;
                rbmol.T = lam;
                
            else
                disp('Cycle not found')
                rbmol.cyclemat = state;
                stategen = 1;
            end
            %}
            
        end %sg
        
        function M = rbmol(rbatom_array, con)
            %from the properties of the atoms making it up and the connectivity defined by con, this
            %constructor function generates the resulting molecule.
            %rbatom_array should be passed as a row vector of atoms, con as a two row
            %cell array whose indices are two vectors of atom index and
            %orbital index.
            [~,na] = size(rbatom_array);
            for i = 1:na
                archarray{1,i} = cp(rbatom_array{1,i});
                buildarray{1,i} = cp(rbatom_array{1,i});
            end
            disp(buildarray)
            M.archive = archarray;   
            M.numorbs = 0;
            M.n = 0;
            for i = 1:na
                M.numorbs = M.numorbs + rbatom_array{i}.numorbs;
                M.n = M.n + rbatom_array{i}.n;
            end
            M.iters = 1500;      % arbitrary amount
            M.seed = [];
            M.initialstate = [];
            M.mboolmat = [];
            M.K = [];
            M.E = [];
            M.isatm = 0;
            
            % separate con into a matrix of atom indices and orbital
            % indices (A and O) for convenience
            [~,numcons] = size(con);
            A = zeros(2,numcons);
            O = zeros(2,numcons);
            for j = 1:numcons
                element1 = cell2mat(con(1,j));
                element2 = cell2mat(con(2,j));
                A(1,j) = element1(1,1);
                A(2,j) = element2(1,1);
                O(1,j) = element1(1,2);
                O(2,j) = element2(1,2);
            end
            % iterate through connection pairs to put molecule together
            % [for connection priority basis see connectatms]
            for i = 1:numcons

               % connect two atoms
               atom1 = buildarray{A(1,i)};
               atom2 = buildarray{A(2,i)};
               
               if A(1,i) ~= A(2,i)
                   connect_atoms(atom1,atom2,O(1,i),O(2,i));
                   % grow the E matrix used to specify division of orbitals
                   % into atoms by filling rows up to n1 with A(1,i) and rows
                   % n1+1 --> n2 with A(2,i). Each row index refers to an orbital in
                   % the molecule, the elements in that row are which atom it
                   % belongs to, and which orbital on that atom it belongs to.
                   % E = [MOind,Atomind,AOind]
                   for m = 1:(atom1.numorbs-atom2.numorbs)
                        M.E = vertcat(M.E,[m,A(1,i),m]);
                   end
                   for m = 1:atom2.numorbs
                        M.E = vertcat(M.E,[m+atom1.numorbs-atom2.numorbs,A(2,i),m]);
                   end
                   % update A/O based on the new indices of atom2: we count
                   % atom2 as part of atom1 now. References to atom2 are
                   % changed to refer to atom1
                   ind = A == A(2,i);
                   A(ind) = A(1,i);

                   % also, orbitals on 2 need to be re-indexed in con matrix
                   O(ind) = O(ind) + (atom1.numorbs-atom2.numorbs);
               else
                   self_connect(atom1, con(:,i));
               end
               
                
            end
            
            con_matrix{2,numcons} = []; %pre-allocate mem
            
            for j = 1:numcons
                element1 = [A(1,j),O(1,j)];
                element2 = [A(2,j),O(2,j)];
                con_matrix{2,j} = element2;
                con_matrix{1,j} = element1;
            end
            M.con = con_matrix;
            M.K = atom1.K;
            M.k = atom1.k;
            M.seed = atom1.seed;
            M.initialstate = atom1.initialstate;
            M.mboolmat = atom1.boolmat;
            M.flashes = atom1.flashes;
            M.D = atom1.D;
            M.selfcon = con;
            M.bonded = atom1.bonded;
            sg(M);      % generate cycle
            M.totals = ft(M);
            
        end % constructor
        
        function findtotals = ft(rbmol)     % uses cyclemat to set totals property
            state = rbmol.cyclemat;
            ssize = size(state);
            m = ssize(1,2);
            T0 = ssize(1,1);
            tots = zeros(1,m);
            for t = 1:T0
                tots = tots + state(t,:);
            end
            rbmol.totals = tots;
            findtotals = 1;
        end %ft
            
        function dispcycle = dc(rbmol)      % displays the found cyclemat as an image sorted by the totals property (calls ft)
            unsorted = rbmol.cyclemat;
            ft(rbmol);
            ttls = rbmol.totals;
            [~,i] = sort(ttls);
            sorted = unsorted(:,i);
            C = imresize(sorted,5,'nearest');
            imshow(C,'Border','tight');
            ttltxt = ['RBN cycle for n = ' num2str(rbmol.n) ' and k = ' num2str(rbmol.k)]; 
            title(ttltxt, 'FontSize', 16, 'FontWeight', 'bold')
            dispcycle = 1;
        end
        
        function cpym = cp(A)
            cpym = rbmol(A.archive, A.selfcon);
            vectorizer(cpym);
      
        end %copymol
        
        %{
        function gcoa = give_copy_of_archive(rbmol)
            archive = rbmol.archive;
            copied_archive{length(archive)} = [];
            for j = 1:length(archive)
                copied_archive{j} = cp(archive{j});
            end
            gcoa = copi
            
        end %gcoa
        %}
    end % methods
end